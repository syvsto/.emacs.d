#+TITLE: My Emacs configuration
#+PROPERTY: tangle "init.el"
#+PROPERTY: header-args :results silent :noweb yes

This configuration focuses on modal bindings and general ergonomics to
reduce risk of RSI while sticking to "the emacs way", meaning it tries
to avoid too much rebinding across packages such as done by ~evil~ and
~evil-collection~.

* Initialization
The config uses ~straight.el~ as the package manager, since it allows
the use of various packages that only are available on
github. Additionally, ~use-package~ is used to configure the packages,
as it allows for clean separation of setting options, and eases deferring
the loading of packages.

** Bootstrap straight

#+BEGIN_SRC emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+END_SRC

** Use-package

With straight installed, ~use-package~ can be installed using the
~(straight-use-package)~ function.

#+BEGIN_SRC emacs-lisp
(straight-use-package 'use-package)
#+END_SRC

Use-package uses the built-in ~package.el~ by default, and eagerly
loads packages.  To reduce startup times and use ~straight~ for
package installation, some options for ~use-package~ need to be set.

#+BEGIN_SRC emacs-lisp
(setq straight-use-package-by-default t)
(setq use-package-always-defer t)
#+END_SRC

** Cleaning up Emacs' trash

By default, emacs will put a lot of files on various places on the
hard drive.  The ~no-littering~ package organizes these files in a
better manner, keeping things more organized.

#+BEGIN_SRC emacs-lisp
  (use-package no-littering
    :demand t)
#+END_SRC

** org-mode pre-load

In order to avoid the built-in ~org-mode~ to be loaded, make sure the
upstream version is loaded before other packages start using
~org-mode~ functionality. Since the upstream repo of ~org-mode~ has
outages from time to time, use a github mirror instead.

#+BEGIN_SRC emacs-lisp
(straight-use-package
  '(org :host github :repo "emacs-straight/org-mode" :local-repo "org"))
#+END_SRC

** Essential libraries for elisp

There are some libraries that are very commonly used when working with elisp, to
alleviate some of the pain points of the language.

~s.el~ contains various convenience functions for working with strings.
#+BEGIN_SRC emacs-lisp
(use-package s)
#+END_SRC

~dash~ contains various convenience functions for working with lists.
#+BEGIN_SRC emacs-lisp
(use-package dash)
#+END_SRC
** Settings important initial settings
   
Some settings *must* be changed to make Emacs usable. Importantly, it
should not be necessary to type "yes" and "no" for every prompt!
However, to avoid killing Emacs by accident, prompt when the
~kill-emacs~ function is called.

#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
  (setq confirm-kill-emacs 'y-or-n-p)
#+END_SRC

Since it is easy to mistype things, the error bell sound of Emacs can
become annoying.  Disable it.

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC

Also, there is not much point in having the menu bar and scroll bars
visible, as the information is available elsewhere.

#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(toggle-scroll-bar -1)
#+END_SRC

* Key binding setup

~meow~ is used for modal editing. The package uses some ideas from the
/kakoune/ editor and integrates those with native emacs bindings and
decent keybind setups for different keyboard layouts (including
/colemak/). In contrast with other, similar packages such as ~objed~,
it does not require much in the way of other packages, though it can
integrate with yasnippet, company, smartparens, etc.

#+BEGIN_SRC emacs-lisp
  (use-package meow
    :defer 1
    :straight (meow :type git
		    :host github
		    :repo "DogLooksGood/meow")
    :config
    (meow-global-mode 1)
    (meow-leader-define-key
     '("s" . swiper)
     '("f f" . counsel-rg)
     '("r" . avy-goto-char-2))
   :custom
    (meow-layout 'colemak))
#+END_SRC

The default meow bindings are quite bare-bones, and requires setting
up a leader key map for maximum effect.

The leader key bindings are structured around two principles:
  - Common navigation commands should have one-key bindings
  - Other bindings should default to using mnemonics

* Ivy, Swiper, and Counsel

The suite of packages called Ivy, Swiper, and Counsel are used as the
general completion framework for Emacs. They provide a lot of
interesting functionality and integration, while feeling light-weight.

All packages are installed when installing ~ivy~. Where appropriate,
built-in functions are replaced by their ~counsel~ variant.

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :init
    (counsel-mode 1))
  (use-package ivy
    :init
    (ivy-mode 1)
    :custom
    (ivy-use-virtual-buffers t)
    (enable-recursive-minibuffers t)
    :bind
    (("C-x C-f" . counsel-find-file)
     (:map minibuffer-local-map
	   ("C-r" . counsel-minibuffer-history))))
#+END_SRC

Swiper provides an alternative to the built-in ~isearch~ for in-buffer
searching. It is bound in the leader key map of ~meow~.

#+BEGIN_SRC emacs-lisp
(use-package swiper)
#+END_SRC

* Looks and layout

** Theme and fonts  
Most themes are optimized for code. Since this Emacs config should be
useable for both code and prose, a theme that supports both is
chosen. ~Poet~ is a nice-looking theme with both colored and
monochrome variants that is well suited for both code and prose.

#+BEGIN_SRC emacs-lisp
  (use-package poet-theme
    :init
    (load-theme 'poet-dark t))
#+END_SRC

The poet theme works much better when both proportional and
fixed-pitch fonts are set.  I'm a sucker for narrow fonts, so I use
Iosevka and Spectral.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'default nil :family "Iosevka" :height 100)
  (set-face-attribute 'fixed-pitch nil :family "Iosevka" :height 100)
  (set-face-attribute 'variable-pitch nil :family "Spectral" :height 110)
#+END_SRC

Variable-pitch fonts should be enabled by default.

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'variable-pitch-mode)
#+END_SRC

** Icons

Iconography allows quickly identifying information about an
object. For instance, files are easier to identify when their file
type is shown as an icon. The ~-all-the-icons~ family of packages
enables icons for various emacs modes.

The base package.
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons)
#+END_SRC

Integration with Dired, which displays file types as an icon.
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode))
#+END_SRC

Integration with Ivy, for showing buffer lists with filetype icons.
Also integrates ~ivy-rich~, which provides additional information in
~ivy-list-buffers~.

#+BEGIN_SRC emacs-lisp :noweb-ref "ivy-rich" :tangle no
  (use-package ivy-rich)
  (use-package all-the-icons-ivy-rich
    :init
    (all-the-icons-ivy-rich-mode 1)
    (ivy-rich-mode 1))
#+END_SRC

IBuffer can also display file types of buffers using all-the-icons.

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-ibuffer
  :init
  (all-the-icons-ibuffer-mode 1))
#+END_SRC

*** Font caches
Emacs may render icons slowly due to the way fonts are cached.
Performance can be increased by not compacting font caches, at the
cost of some RAM.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-compacting-font-caches t)
#+END_SRC

** Showing key bindings
~which-key~ displays the key bindings available for a hotkey after a
short while. This helps discoverability immensely.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :init
    (which-key-mode))
#+END_SRC
   
** Layout

When writing prose, I want the layout be as distraction-free as
possible. Olivetti-mode supports this with minimal fuzz. Olivetti
defaults to a width of 70, which is a tad too narrow for my taste, so
it is raised to 80.

#+BEGIN_SRC emacs-lisp
  (use-package olivetti
    :hook (text-mode . olivetti-mode)
    :custom
    (olivetti-body-width 80))
#+END_SRC

** Delimiter highlighting

When working with code, identifying the current nesting based on
parenthesis color is useful. The ~rainbow-delimiters~ package colors
different nestings by different parenthesis colors.

#+BEGIN_SRC emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
#+END_SRC

* Windows, projects, and buffers
  
Emacs comes with ~winner-mode~, which allows navigating to old window layouts.
Great if you accidentally close your windows!

#+BEGIN_SRC emacs-lisp
(winner-mode 1)
#+END_SRC

** Project management

~Project.el~ is shipping with newer versions of Emacs and can replace
my uses of ~projectile~ while being a simpler package. In Emacs 27 and
beyond, project.el has a default binding of ~<C-x p>~.

NOTE: ~project.el~ needs access to a ~find~ executable which is unavailable
on Windows by default, so MSYS2 or Cygwin must be installed. 

** Buffer management
IBuffer is a built-in replacement for list-buffers which is much nicer
and with a lot of additional functionality. Together with ~ivy-rich~,
this provides a good-enough buffer management experience.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC

** Windows
   
The ~ace-window~ package is great for jumping between windows.
The [[https://github.com/abo-abo/ace-window#change-the-action-midway][dispatch keys]] are very useful!

#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :bind ("M-o" . ace-window))
#+END_SRC

* Navigation

Avy is fantastic for jumping around the buffer. I'm partial to the
two-key jump, word jump, and line jump, since that combination allows
moving anywhere on screen pretty easily. Avy is important enough that
it gets it's own leader key bindings, so ~avy-goto-char-2~ is bound
there.

Combined with ~swiper~ for in-buffer search and ~counsel-rg~ for
cross-buffer search, it is easy to navigate anywhere quite easily.

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :bind (("M-g M-g" . avy-goto-line)
	   ("M-g g" . avy-goto-line)
	   ("M-g w" . avy-goto-word-1)))
#+END_SRC

* Prose and life management

By default, text should auto-fill to 80 characters. This makes it
easier to work with olivetti, and makes vertical splits much more
comfortable.

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'auto-fill-mode)
#+END_SRC

* Programming
  
* Version control

Magit is the best git client ever.
#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind ("C-x g" . magit-status))
#+END_SRC

* Supporting code

Ivy-rich must be enabled after other ivy integrations, so enabling it
is deferred to the end of initialization.

#+BEGIN_SRC emacs-lisp
<<ivy-rich>>
#+END_SRC
