#+TITLE: My Emacs configuration
#+PROPERTY: tangle "init.el"
#+PROPERTY: header-args :results silent :noweb yes

This configuration focuses on modal bindings and general ergonomics to reduce
risk of RSI while sticking to "the emacs way", meaning it tries to avoid too
much rebinding across packages such as done by spacemacs and doom.

* Initialization

The config uses ~straight.el~ as the package manager, since it allows the use of
various packages that only are available on github. Additionally, ~use-package~ is
used to configure the packages, as it allows for clean separation of setting
options, and eases deferring the loading of packages.

** Bootstrap straight

The ~straight.el~ bootstrap code is performed in the ~init.el~ file because ~straight~
needs to make sure it controls which version of ~org~ is loaded, and I tangle this
file on startup.

In order to avoid loading the built-in ~org-mode~, the ~init.el~ file makes sure the
upstream version is loaded before other packages start using ~org-mode~
functionality.

** Use-package

With straight installed, ~use-package~ can be installed using the
~(straight-use-package)~ function.

#+BEGIN_SRC emacs-lisp
  (straight-use-package 'use-package)
#+END_SRC

Use-package uses the built-in ~package.el~ by default, and eagerly loads packages.
To reduce startup times and use ~straight~ for package installation, some options
for ~use-package~ need to be set.

#+BEGIN_SRC emacs-lisp
  (setq straight-use-package-by-default t)
  (setq use-package-always-defer t)
#+END_SRC

~use-package~ requires the ~delight~ package to hide things on the mode line using
the ~:delight~ keyword, which is the simplest way of hiding modeline lighters.

#+begin_src emacs-lisp
  (use-package delight
    :init
    (delight '((buffer-face-mode))))
#+end_src

** Cleaning up Emacs' trash

By default, emacs will put a lot of files on various places on the hard drive.
The ~no-littering~ package organizes these files in a better manner, keeping
things more organized.

#+BEGIN_SRC emacs-lisp
  (use-package no-littering
    :demand t)
#+END_SRC

** Essential libraries for elisp

There are some libraries that are very commonly used when working with elisp, to
alleviate some of the pain points of the language.

~s.el~ contains various convenience functions for working with strings.

#+BEGIN_SRC emacs-lisp
  (use-package s)
#+END_SRC

~dash~ contains various convenience functions for working with lists.

#+BEGIN_SRC emacs-lisp
  (use-package dash)
#+END_SRC

** Environment variables

On MacOS, you often don't get the correct $PATH when using GUI Emacs. The
~exec-path-from-shell~ package fixes this.

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :commands (exec-path-from-shell-initialize)
    :init
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))
#+end_src

** Important initial settings
   
Some settings *must* be changed to make Emacs usable. Importantly, it should not
be necessary to type "yes" and "no" for every prompt!  However, to avoid killing
Emacs by accident, prompt when the ~kill-emacs~ function is called.

#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
  (setq confirm-kill-emacs 'y-or-n-p)
#+END_SRC

Since it is easy to mistype things, the error bell sound of Emacs can become
annoying.  Disable it.

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

Also, there is not much point in having the menu bar and scroll bars visible, as
the information is available elsewhere.

#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (toggle-scroll-bar -1)
#+END_SRC

Emacs should use UTF-8 encoding by default, as has become common.
#+begin_src emacs-lisp
  (prefer-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-language-environment 'utf-8)
  (set-selection-coding-system 'utf-8)
#+end_src

Finally, get rid of the default splash screen and jump straight to a scratch
buffer.

#+begin_src emacs-lisp
  (setq inhibit-startup-screen t)
  (setq inhibit-startup-message t)
  (setq initial-scratch-message ";; INITIALIZED...")
#+end_src

** Mac specifics 

On Mac, I like keeping the right alt modifier as-is, to be able to input special
characters with ease.

#+begin_src emacs-lisp
  (setq ns-right-alternate-modifier nil)
#+end_src

A small aesthetic change is keeping the title bar and theme in the same color.

#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
#+end_src

* Key bindings and navigation

Vim bindings for that sweet RSI relief.

#+begin_src emacs-lisp
    (use-package evil
      :init
      (setq evil-want-keybinding nil)
      :hook (after-init . evil-mode))

    (use-package evil-collection
      :hook (evil-mode . evil-collection-init))

    (use-package evil-magit
      :hook (evil-mode . evil-magit-init))
#+end_src

Some additional plugins are essential.
#+begin_src emacs-lisp
  (use-package evil-surround
    :hook (evil-mode . global-evil-surround-mode))

  (use-package evil-commentary
    :hook (evil-mode . evil-commentary-mode))
#+end_src

** Selectrum and presicent

=Selectrum= and the =prescient= selection styles are used for candidate selection,
as they are lightweight and makes it easy to select commonly used candidates.

#+BEGIN_SRC emacs-lisp
  (use-package selectrum
    :hook (after-init . selectrum-mode))
#+END_SRC

Prescient makes candidate sorting more intelligent, and persists between
sessions.
#+begin_src emacs-lisp
    (use-package prescient)
    (use-package selectrum-prescient
      :hook ((after-init . selectrum-prescient-mode)
	     (after-init . prescient-persist-mode)))
#+end_src

** Ctrlf

CtrlF is similar to the built-in ISearch, but is more robust.

#+BEGIN_SRC emacs-lisp
  (use-package ctrlf
    :hook (after-init . ctrlf-mode))
#+END_SRC

When searching across buffers, I like ~ripgrep~, which can be invoked
with the =rg.el= package.

#+begin_src emacs-lisp
  (use-package deadgrep
    :bind ("<f7>" . deadgrep))
#+end_src

** Anzu

I rely on search and replace a lot. The ~anzu~ package provides a nicer interface
to the built-in search and replace, and by rebinding the built-in commands, anzu
gets nicely integrated into ~evil~ as well.

#+begin_src emacs-lisp
  (use-package anzu
    :delight
    :init
    (global-anzu-mode +1)
    (global-set-key [remap query-replace] 'anzu-query-replace)
    (global-set-key [remap query-replace-regexp] 'anzu-query-replace-regexp))
#+end_src

** Imenu

IMenu is a useful, built-in navigation tool for many modes, but is unbound. Bind to ~M-i~,
since that's only used for indentation by default.
#+begin_src emacs-lisp
  (bind-key "M-i" 'imenu)
#+end_src

** Kill ring navigation

It can be a hassle to navigate the kill ring manually (~C-y M-y M-y M-y~
etc.). =browse-kill-ring= brings up the kill ring as a navigable buffer for easier
candidate selection.

#+begin_src emacs-lisp
  (use-package browse-kill-ring
    :bind ("M-y" . browse-kill-ring))
#+end_src

* Looks and layout

** Theme and fonts  
Most themes are optimized for code. Since this Emacs config should be useable
for both code and prose, a theme that supports both is chosen. ~Modus Operandi~
and ~Modus Vivendi~ are nice light and dark themes with a focus on accessibility
and support for any mode under the sun. For the most part, I like the light
variant.

#+BEGIN_SRC emacs-lisp
  (use-package modus-operandi-theme
    :init
    (setq modus-operandi-theme-variable-pitch-headings t
	  modus-operandi-theme-slanted-constructs t
	  modus-operandi-theme-bold-constructs t
	  modus-operandi-theme-scale-headings t
	  modus-operandi-theme-scale-1 1.05
	  modus-operandi-theme-scale-2 1.1
	  modus-operandi-theme-scale-3 1.15
	  modus-operandi-theme-scale-4 1.2
	  modus-operandi-theme-scale-5 1.3
	  modus-operandi-theme-org-blocks 'rainbow)
    (load-theme 'modus-operandi t))

  (use-package modus-vivendi-theme)
#+END_SRC

The modus themes work much better for writing when both proportional and
fixed-pitch fonts are set.  I'm a sucker for narrow fonts, so I use Iosevka and
Spectral.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'default nil :family "Iosevka" :height 140)
  (set-face-attribute 'fixed-pitch nil :family "Iosevka" :height 140)
  (set-face-attribute 'variable-pitch nil :family "Spectral" :height 150)
#+END_SRC

Variable-pitch fonts should be enabled by default.

#+BEGIN_SRC emacs-lisp
  (add-hook 'text-mode-hook 'variable-pitch-mode)
#+END_SRC

** Modeline

The modeline can also use a little facelift.
#+begin_src emacs-lisp
    (use-package mood-line
      :hook (after-init . mood-line-mode))
#+end_src

I like seeing the current time when I'm working, as I often run Emacs in
full-screen mode. I don't need to see my computer's load level, so that is
hidden.

#+begin_src emacs-lisp
  (display-time-mode 1)
  (setq display-time-default-load-average nil)
  (setq display-time-format " %k:%M")
#+end_src

** Icons

Iconography allows quickly identifying information about an object. For
instance, files are easier to identify when their file type is shown as an
icon. The ~all-the-icons~ family of packages enables icons for various emacs
modes.

The base package.
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)
#+END_SRC

Integration with Dired, which displays file types as an icon.

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode))
#+END_SRC

IBuffer can also display file types of buffers using all-the-icons.

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons-ibuffer
    :init
    (all-the-icons-ibuffer-mode 1))
#+END_SRC

*** Font caches

Emacs may render icons slowly due to the way fonts are cached.  Performance can
be increased by not compacting font caches, at the cost of some RAM.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-compacting-font-caches t)
#+END_SRC

** Showing key bindings

~which-key~ displays the key bindings available for a hotkey after a
short while. This helps discoverability immensely.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :delight
    :init
    (which-key-mode))
#+END_SRC
   
** Layout

When writing prose, I want the layout be as distraction-free as
possible. Olivetti-mode supports this with minimal fuzz. Olivetti defaults to a
width of 70, which is a tad too narrow for my taste, so it is raised to 80.

#+BEGIN_SRC emacs-lisp
  (use-package olivetti
    :hook (text-mode . olivetti-mode)
    :custom
    (olivetti-body-width 80))
#+END_SRC

Emacs is commonly used maximized. Default to maximizing Emacs on startup.

#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

** Rainbow delimiters

Rainbow delimiters make it easier to spot nesting of parentheses etc.
#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

* Windows, projects, and buffers
  
Emacs comes with ~winner-mode~, which allows navigating to old window layouts.
Great if you accidentally close your windows!

#+BEGIN_SRC emacs-lisp
  (winner-mode 1)
#+END_SRC

** Project management

~Project.el~ is shipping with newer versions of Emacs and can replace my uses of
~projectile~ while being a simpler package. In Emacs 27 and beyond, project.el has
a default binding of ~<C-x p>~.

NOTE: ~project.el~ needs access to a ~find~ executable which is unavailable on
Windows by default, so MSYS2 or Cygwin must be installed.

** Buffer management
IBuffer is a built-in replacement for list-buffers which is much nicer and with
a lot of additional functionality. It can be used in conjunction with the
=perspective.el= wrapper ~persp-ibuffer~ to show only buffers in the current
perspective. It is bound in the [[*Perspectives][perspective section]] of this document.

** Windows
   
The ~ace-window~ package is great for jumping between windows.  The [[https://github.com/abo-abo/ace-window#change-the-action-midway][dispatch keys]]
are very useful!

#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :bind ("M-o" . ace-window))
#+END_SRC

Emacs has a tendency to go a bit crazy and creating windows all over the
place. [[https://github.com/nex3/perspective-el][The perspective.el readme]] suggests the following settings to have Emacs
reuse more of the existing windows.

#+begin_src emacs-lisp
(setq display-buffer-alist
      '((".*" (display-buffer-reuse-window display-buffer-same-window))))

(setq display-buffer-reuse-frames t)         ; reuse windows in other frames
(setq even-window-sizes nil)                 ; display-buffer: avoid resizing
#+end_src

** File system

Dired is great for generic movement around the file system, as well as generic
options such as copying and renaming files across folders. However, it defaults
to displaying too much information, and feels cluttered. Disable this extra
information. If needed, it is available under the ~(~ key.

#+begin_src emacs-lisp
  (use-package dired
    :straight nil
    :ensure nil
    :hook (dired-mode . dired-hide-details-mode))
#+end_src

Treemacs is  nice for working with files in-project, and is a dependency of
=lsp-mode=, so it is available for use anyways.
#+begin_src emacs-lisp
  (use-package treemacs
    :bind ("<f2>" . treemacs))
#+end_src

* Prose and life management

By default, text should auto-fill to 80 characters. This makes it easier to work
with olivetti, and makes vertical splits much more comfortable.

#+BEGIN_SRC emacs-lisp
  (setq-default fill-column 80)
  (add-hook 'text-mode-hook 'auto-fill-mode)
#+END_SRC

** Org mode

Instead of indenting all text to match the header, I like only indenting the
header, so that I have more horizontal characters for each line.

#+BEGIN_SRC emacs-lisp
  (setq org-indent-indentation-per-level 1)
  (setq org-adapt-indentation nil)
#+END_SRC

The leading stars in headers can be visually noisy for very nested documents, so
they are disabled. ~org-bullets-mode~ is another option, but has been causing
slowdowns for some larger org documents.

#+BEGIN_SRC emacs-lisp
  (setq org-hide-leading-stars 't)
#+END_SRC

When reading documents, it's better if markup is hidden unless hovered.

#+BEGIN_SRC emacs-lisp
  (setq org-hide-emphasis-markers t)
#+END_SRC

Org has a tendency to do weird stuff with whitespace when toggling
headings. Disable this behavior. Also, display the spacing between headings even
when they are closed.

#+BEGIN_SRC emacs-lisp
  (setq org-cycle-separator-lines 1)
  (customize-set-variable 'org-blank-before-new-entry
			  '((heading . nil)
			    (plain-list-item . nil)))
#+END_SRC

Globally useful org commands such as ~org-store-link~ are made available in the
leader key bindings under the "a" prefix.

#+begin_src emacs-lisp :noweb-ref "leader-org" :tangle no
  '("a c" . org-capture)
  '("a l" . org-store-link)
#+end_src


*** The agenda

The org files needed for my agenda is available in my Dropbox folder.

#+begin_src emacs-lisp
  (setq my/org-agenda-dir "~/Dropbox/orgfiles/")
#+end_src

#+begin_src emacs-lisp
    (setq org-directory my/org-agenda-dir
	  org-agenda-files (concat user-emacs-directory "agenda-files"))
#+end_src

Org capture requires capture templates to be the most useful.

#+begin_src emacs-lisp
  (setq org-capture-templates
	`(("i" "inbox" entry (file ,(concat my/org-agenda-dir "inbox.org"))
	   "* TODO %?")))
#+end_src

Org agenda is nice for seeing an overview of the state of various org files at
once. Set it up so it shows my todos from various files.

#+begin_src emacs-lisp
  (setq my/org-agenda-todo-view
	`(" " "Agenda"
	  ((agenda ""
		   ((org-agenda-span 'day)
		    (org-deadline-warning-days 365)))
	   (todo "TODO"
		 ((org-agenda-overriding-header "Inbox")
		  (org-agenda-files '(,(concat my/org-agenda-dir "inbox.org")))))
	   (todo "TODO"
		 ((org-agenda-overriding-header "Eposter")
		  (org-agenda-files '(,(concat my/org-agenda-dir "emails.org")))))
	   (todo "NEXT"
		 ((org-agenda-overriding-header "In Progress")
		  (org-agenda-files '(,(concat my/org-agenda-dir "someday.org")
				      ,(concat my/org-agenda-dir "projects.org")
				      ,(concat my/org-agenda-dir "next.org")))
		  ))
	   (todo "TODO"
		 ((org-agenda-overriding-header "Prosjekter")
		  (org-agenda-files '(,(concat my/org-agenda-dir "projects.org")))
		  ))
	   (todo "TODO"
		 ((org-agenda-overriding-header "Enkeltoppgaver")
		  (org-agenda-files '(,(concat my/org-agenda-dir "next.org")))
		  (org-agenda-skip-function '(org-agenda-skip-entry-if 'deadline 'scheduled))))
	   nil)))

  (use-package org
    :init
    (setq org-agenda-custom-commands (list my/org-agenda-todo-view)))
#+end_src

Show todo items in agenda that have been set to done in this session, or are
scheduled for today.

#+begin_src emacs-lisp
  (setq org-agenda-start-with-log-mode t)
#+end_src

There are some unnecessary horizontal lines in the agenda that take up space and
clutter the view. Remove them.
#+begin_src emacs-lisp
  (setq org-agenda-block-separator nil)
#+end_src

Make the agenda real easy to get to, to reduce overhead when working with task
management. This binds a shortcut to my agenda view to ~<F1>~.

#+begin_src emacs-lisp
  (defun my/org-agenda ()
    "Show my org agenda"
    (interactive)
    (org-agenda nil " "))

  (bind-key "<f1>" 'my/org-agenda)
#+end_src


***** Refiling

Org mode is better if you can move stuff around easily. This is called refiling.
#+begin_src emacs-lisp
  (setq org-refile-use-outline-path 'file
	org-outline-path-complete-in-steps nil)
#+end_src

I need some targets to refile to.

#+begin_src emacs-lisp
  (setq org-refile-targets '(("next.org" :level . 0)
			     ("someday.org" :level . 0)
			     ("calendar.org" :level . 0)
			     ("emails.org" :level . 0)
			     ("projects.org" :maxlevel . 1)))
#+end_src
 
** Markdown

Sometimes I work with markdown, for instance when writing documentation for
packages at work.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :mode (("README\\.md\\'" . gfm-mode)
	   ("\\.md\\'" . markdown-mode)
	   ("\\.markdown\\'" . markdown-mode))
    :init
    (setq markdown-command "multimarkdown"))
#+end_src

** PDF-tools

PDF-tools lets you view and work with PDFs directly from within Emacs!

#+begin_src emacs-lisp
  (use-package pdf-tools
    :config
    (pdf-tools-install))
#+end_src

* Programming

** Autocompletion

The =company= package provides autocompletion, and is integrated with LSP.

#+begin_src emacs-lisp
  (use-package company
    :hook (prog-mode . company-mode)
    :config
    (setq company-idle-delay 0.0))
#+end_src

Company also supports =prescient= candidate sorting.

#+begin_src emacs-lisp
  (use-package company-prescient
    :after company
    :config
    (company-presient-mode +1))
#+end_src

** Snippets

Yasnippet is used for snippet support.

#+begin_src emacs-lisp
  (use-package yasnippet
    :init
    (yas-global-mode))
#+end_src

A bunch of default snippets are found in an external package.

#+begin_src emacs-lisp
      (use-package yasnippet-snippets
	:config
	(yasnippet-snippets-initialize))
#+end_src

** Errors

Flycheck performs error checking. There is also the built-in ~flymake~, but I've
had crashes on Windows when ~flymake~ tries to check a buffer that's currently
used by another process (such as when formatting a buffer).

#+begin_src emacs-lisp
  (use-package flycheck)
#+end_src

Integration with ~lsp-mode~ is automatic.

** LSP

The main coding environment is provided by the ~lsp-mode~ package family, which
just keeps getting better and better.

It is available under the ~<f6>~ prefix.

#+begin_src emacs-lisp
  (use-package lsp-mode
    :hook ((lsp-mode . lsp-enable-which-key-integration))
    :custom
    (lsp-keymap-prefix "<f6>")
    (lsp-prefer-capf t))
#+end_src

~lsp-ui~ provides some nice additional features such as a peek mode for finding
references and documentation display. However, I don't like the sideline
display, as it is too noisy.

#+begin_src emacs-lisp
  (use-package lsp-ui
    :commands lsp-ui-mode
    :hook (lsp-mode . lsp-ui-mode)
    :custom
    (lsp-ui-sideline-enable nil)
    (lsp-ui-doc-enable nil)
    :config
    <<lsp-ui-peek-binds>>)
#+end_src

In buffers with ~lsp-ui~ enabled, rebind the ~xref~ commands to use the peek mode.

#+begin_src emacs-lisp :noweb-ref "lsp-ui-peek-binds" :tangle no
  (define-key lsp-ui-mode-map [remap xref-find-definitions] #'lsp-ui-peek-find-definitions)
  (define-key lsp-ui-mode-map [remap xref-find-references] #'lsp-ui-peek-find-references)
#+end_src

** Debugging

The ~lsp-mode~ supports debugging through the Debug Adapter Protocol.
It is available when LSP is enabled, but only for filetypes that have
a DAP adapter installed.

#+begin_src emacs-lisp
  (use-package dap-mode
    :commands (dap-mode dap-debug dap-hydra/body))
#+end_src

The ~dap-mode~ binding setup is used for modes that support debugging.

#+begin_src emacs-lisp :noweb-ref "dap-bindings" :tangle no
  ("M-<f5>" . dap-debug)
  ("<f5>" . dap-hydra/body)
#+end_src

** Structured editing

Smartparens enables features of structured editing into any language that can
display pairs. 

#+begin_src emacs-lisp
  (use-package smartparens
    :delight
    :commands (sp-local-pair smartparens-global-mode sp-use-paredit-bindings)
    :init
    (sp-local-pair 'emacs-lisp-mode "`" "'")
    (sp-local-pair 'emacs-lisp-mode "'" nil :actions nil)
    (smartparens-global-mode)
    (sp-use-paredit-bindings))
#+end_src

** Languages

*** JavaScript

In Emacs 27, there is a new built-in JavaScript mode which is much better than
earlier modes, and supports JSX syntax well.

#+begin_src emacs-lisp
  (use-package js-mode
    :straight nil
    :hook ((js-mode . lsp-deferred)
	   (js-mode . dap-auto-configure-mode)
	   (js-mode . (lambda () (setq tab-width 2)))
	   (js-jsx-mode . lsp-deferred)
	   (js-jsx-mode . dap-auto-configure-mode))
    :bind ((:map js-mode-map
		 ("M-." . xref-find-references)
		 <<dap-bindings>>)
	   (:map js-jsx-mode-map
		 <<dap-bindings>>))
    )
#+end_src

I often use =prettier= as my formatter. The =prettier.el= package is good for
handling autoformat on save etc. ~global-prettier-mode~ enables Prettier for
javascript, typescript etc.

#+begin_src emacs-lisp
  (use-package prettier-js
    :hook ((js-mode scss-mode css-mode json-mode) . prettier-js-mode))
#+end_src

*** JSON

JSON-mode includes some niceties for working with JSON, including a formatter in ~json-format~.
#+begin_src emacs-lisp
(use-package json-mode)
#+end_src

*** Rust

Rust is well-supported by the ~rust-analyzer~ LSP server. The ~rustic~ mode
automatically sets up all the things you'd like to have when working with Rust
and Emacs.

#+begin_src emacs-lisp
  (use-package rustic
    :commands (rustic-mode)
    :custom
    (rustic-lsp-server 'rust-analyzer))
#+end_src

Rustic supports a popup for controlling various compilation, testing
etc. commands. By default it is bound to ~<C-c C-p>~.

*** Haskell

Haskell does not yet have great LSP support in Emacs, though it is in the works in the
form of =haskell-language-server=. Instead, the emacs =haskell-mode= contains a lot
of useful features for working with Haskell.

#+begin_src emacs-lisp
  (use-package haskell-mode
    :bind (:map haskell-mode-map
		("<f8>" . haskell-navigate-imports))
    :hook ((haskell-mode . haskell-auto-insert-module-template)))
#+end_src

This sets up Dante, with the assumption that nix is installed and used.

#+begin_src emacs-lisp
  (use-package dante
    :after haskell-mode
    :commands 'dante-mode
    :hook ((haskell-mode . flycheck-mode)
	   (haskell-mode . dante-mode))
    :config
    (setq dante-methods '(new-build bare-ghci))
    (setq flycheck-hlintrc ".hlint.yaml")
    (flycheck-add-next-checker 'haskell-dante '(info . haskell-hlint)))
#+end_src

=Attrap= adds various code actions to =dante= (on windows you need to set the beta
option for UTF-8 in Region settings for it to work).
#+begin_src emacs-lisp
  (use-package attrap)
#+end_src

*** Nix

Nix syntax  is used to write code for the Nix package management/build/system
management/OS tool.

#+begin_src emacs-lisp
  (use-package nix-mode)
#+end_src

* Version control

Magit is the best git client ever.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind ("C-x g" . magit-status))
#+END_SRC

When programming, it is useful to see which lines have been changed when editing
a file. ~Git-Gutter~ does this. I like the ~git-gutter-+~ package which has a nice
minimal skin.

#+BEGIN_SRC emacs-lisp
  (use-package git-gutter-fringe+
    :delight
    :hook (prog-mode . git-gutter+-mode)
    :init
    (require 'git-gutter-fringe+)
    (git-gutter-fr+-minimal)
    (git-gutter+-toggle-fringe))
#+END_SRC

Every once in a while it's nice to visit older versions of a file. Magit can do
this, but is somewhat cumbersome to use. ~git-timemachine~ provides an easy-to-use
alternative.

#+BEGIN_SRC emacs-lisp
  (use-package git-timemachine
    :delight
    :commands (git-timemachine)
    :bind ("C-x M-g" . git-timemachine))
#+END_SRC
