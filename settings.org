#+TITLE: My Emacs configuration
#+PROPERTY: tangle "init.el"
#+PROPERTY: header-args :results silent :noweb yes

This configuration focuses on modal bindings and general ergonomics to
reduce risk of RSI while sticking to "the emacs way", meaning it tries
to avoid too much rebinding across packages such as done by ~evil~ and
~evil-collection~.

* Initialization
The config uses ~straight.el~ as the package manager, since it allows
the use of various packages that only are available on
github. Additionally, ~use-package~ is used to configure the packages,
as it allows for clean separation of setting options, and eases deferring
the loading of packages.

** Bootstrap straight

#+BEGIN_SRC emacs-lisp
(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))
#+END_SRC

** Use-package

With straight installed, ~use-package~ can be installed using the
~(straight-use-package)~ function.

#+BEGIN_SRC emacs-lisp
(straight-use-package 'use-package)
#+END_SRC

Use-package uses the built-in ~package.el~ by default, and eagerly
loads packages.  To reduce startup times and use ~straight~ for
package installation, some options for ~use-package~ need to be set.

#+BEGIN_SRC emacs-lisp
(setq straight-use-package-by-default t)
(setq use-package-always-defer t)
#+END_SRC

~use-package~ requires the ~delight~ package to hide things on the mode
line using the ~:delight~ keyword, which is the simplest way of hiding
modeline lighters.

#+begin_src emacs-lisp
  (use-package delight
    :init
    (delight '((buffer-face-mode))))
#+end_src

** Cleaning up Emacs' trash

By default, emacs will put a lot of files on various places on the
hard drive.  The ~no-littering~ package organizes these files in a
better manner, keeping things more organized.

#+BEGIN_SRC emacs-lisp
  (use-package no-littering
    :demand t)
#+END_SRC

** org-mode pre-load

In order to avoid the built-in ~org-mode~ to be loaded, make sure the
upstream version is loaded before other packages start using
~org-mode~ functionality. Since the upstream repo of ~org-mode~ has
outages from time to time, use a github mirror instead.

#+BEGIN_SRC emacs-lisp
(straight-use-package
  '(org :host github :repo "emacs-straight/org-mode" :local-repo "org"))
#+END_SRC

** Essential libraries for elisp

There are some libraries that are very commonly used when working with elisp, to
alleviate some of the pain points of the language.

~s.el~ contains various convenience functions for working with strings.
#+BEGIN_SRC emacs-lisp
(use-package s)
#+END_SRC

~dash~ contains various convenience functions for working with lists.
#+BEGIN_SRC emacs-lisp
(use-package dash)
#+END_SRC

** Important initial settings
   
Some settings *must* be changed to make Emacs usable. Importantly, it
should not be necessary to type "yes" and "no" for every prompt!
However, to avoid killing Emacs by accident, prompt when the
~kill-emacs~ function is called.

#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
  (setq confirm-kill-emacs 'y-or-n-p)
#+END_SRC

Since it is easy to mistype things, the error bell sound of Emacs can
become annoying.  Disable it.

#+BEGIN_SRC emacs-lisp
(setq ring-bell-function 'ignore)
#+END_SRC

Also, there is not much point in having the menu bar and scroll bars
visible, as the information is available elsewhere.

#+BEGIN_SRC emacs-lisp
(tool-bar-mode -1)
(menu-bar-mode -1)
(toggle-scroll-bar -1)
#+END_SRC

Finally, get rid of the default splash screen and jump straight to a
scratch buffer.

#+begin_src emacs-lisp
(setq inhibit-startup-screen t)
(setq inhibit-startup-message t)
(setq initial-scratch-message ";; INITIALIZED...")
#+end_src

* Key binding setup

~meow~ is used for modal editing. The package uses some ideas from the
/kakoune/ editor and integrates those with native emacs bindings and
decent keybind setups for different keyboard layouts (including
/colemak/). In contrast with other, similar packages such as ~objed~,
it does not require much in the way of other packages, though it can
integrate with yasnippet, company, smartparens, etc.

#+BEGIN_SRC emacs-lisp
  (use-package meow
    :defer 1
    :commands (meow-global-mode meow-leader-define-key meow-leader-define-mode-key)
    :straight (meow :type git
		    :host github
		    :repo "DogLooksGood/meow")
    :config
    (meow-global-mode 1)
    (meow-leader-define-key
     <<leader-ivy>>
     <<leader-avy>>
     <<leader-org>>
     )
   :custom
    (meow-layout 'colemak))
#+END_SRC

The default meow bindings are quite bare-bones, and requires setting
up a leader key map for maximum effect.

The leader key bindings are structured around two principles:
  - Common navigation commands should have one-key bindings
  - Other bindings should default to using mnemonics

* Ivy, Swiper, and Counsel

The suite of packages called Ivy, Swiper, and Counsel are used as the
general completion framework for Emacs. They provide a lot of
interesting functionality and integration, while feeling light-weight.

All packages are installed when installing ~ivy~. Where appropriate,
built-in functions are replaced by their ~counsel~ variant.

#+BEGIN_SRC emacs-lisp
  (use-package counsel
    :delight
    :init
    (counsel-mode 1))
    
  (use-package ivy
    :delight
    :init
    (ivy-mode 1)
    :custom
    (ivy-use-virtual-buffers t)
    (enable-recursive-minibuffers t)
    :bind
    (("C-x C-f" . counsel-find-file)
     (:map minibuffer-local-map
	   ("C-r" . counsel-minibuffer-history))))
#+END_SRC

Swiper provides an alternative to the built-in ~isearch~ for in-buffer
searching. It is bound in the leader key map of ~meow~.

#+BEGIN_SRC emacs-lisp
(use-package swiper)
#+END_SRC

When searching across buffers, I like ~ripgrep~, which can be invoked
with ~counsel-rg~.
#+begin_src emacs-lisp :noweb-ref "leader-ivy" :tangle no
'("s" . swiper)
'("f f" . counsel-rg)
#+end_src

** Anzu

Though not really part of the ~ivy~ universe, I rely on search and
replace a lot. The ~anzu~ package provides a nicer interface to the
built-in search and replace, and by rebinding the built-in commands,
anzu gets nicely integrated into ~meow~ as well.

#+begin_src emacs-lisp
  (use-package anzu
    :init
    (global-anzu-mode +1)
    (global-set-key [remap query-replace] 'anzu-query-replace)
    (global-set-key [remap query-replace-regexp] 'anzu-query-replace-regexp))
#+end_src

* Looks and layout

** Theme and fonts  
Most themes are optimized for code. Since this Emacs config should be
useable for both code and prose, a theme that supports both is
chosen. ~Modus Operandi~ and ~Modus Vivendi~ are nice light and dark
themes with a focus on accessibility and support for any mode under
the sun. For the most part, I like the light variant.

#+BEGIN_SRC emacs-lisp
    (use-package modus-operandi-theme
      :init
      (setq modus-operandi-theme-variable-pitch-headings t
	    modus-operandi-theme-slanted-constructs t
	    modus-operandi-theme-bold-constructs t
	    modus-operandi-theme-3d-modeline t
	    modus-operandi-theme-scale-headings t
	    modus-operandi-theme-scale-1 1.05
	    modus-operandi-theme-scale-2 1.1
	    modus-operandi-theme-scale-3 1.15
	    modus-operandi-theme-scale-4 1.2
	    modus-operandi-theme-scale-5 1.3
	    modus-operandi-theme-org-blocks 'rainbow)
      (load-theme 'modus-operandi t))

    (use-package modus-vivendi-theme)
#+END_SRC

The modus themes work much better for writing when both proportional and
fixed-pitch fonts are set.  I'm a sucker for narrow fonts, so I use
Iosevka and Spectral.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'default nil :family "Iosevka" :height 100)
  (set-face-attribute 'fixed-pitch nil :family "Iosevka" :height 100)
  (set-face-attribute 'variable-pitch nil :family "Spectral" :height 110)
#+END_SRC

Variable-pitch fonts should be enabled by default.

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'variable-pitch-mode)
#+END_SRC

** Icons

Iconography allows quickly identifying information about an
object. For instance, files are easier to identify when their file
type is shown as an icon. The ~-all-the-icons~ family of packages
enables icons for various emacs modes.

The base package.
#+BEGIN_SRC emacs-lisp
(use-package all-the-icons)
#+END_SRC

Integration with Dired, which displays file types as an icon.
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode))
#+END_SRC

Integration with Ivy, for showing buffer lists with filetype icons.
Also integrates ~ivy-rich~, which provides additional information in
~ivy-list-buffers~.

#+BEGIN_SRC emacs-lisp :noweb-ref "ivy-rich" :tangle no
  (use-package ivy-rich)
  (use-package all-the-icons-ivy-rich
    :init
    (all-the-icons-ivy-rich-mode 1)
    (ivy-rich-mode 1))
#+END_SRC

IBuffer can also display file types of buffers using all-the-icons.

#+BEGIN_SRC emacs-lisp
(use-package all-the-icons-ibuffer
  :init
  (all-the-icons-ibuffer-mode 1))
#+END_SRC

*** Font caches
Emacs may render icons slowly due to the way fonts are cached.
Performance can be increased by not compacting font caches, at the
cost of some RAM.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-compacting-font-caches t)
#+END_SRC

** Showing key bindings
~which-key~ displays the key bindings available for a hotkey after a
short while. This helps discoverability immensely.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :delight
    :init
    (which-key-mode))
#+END_SRC
   
** Layout

When writing prose, I want the layout be as distraction-free as
possible. Olivetti-mode supports this with minimal fuzz. Olivetti
defaults to a width of 70, which is a tad too narrow for my taste, so
it is raised to 80.

#+BEGIN_SRC emacs-lisp
  (use-package olivetti
    :hook (text-mode . olivetti-mode)
    :custom
    (olivetti-body-width 80))
#+END_SRC

Emacs is commonly used maximized. Default to maximizing Emacs on
startup.

#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

* Windows, projects, and buffers
  
Emacs comes with ~winner-mode~, which allows navigating to old window layouts.
Great if you accidentally close your windows!

#+BEGIN_SRC emacs-lisp
(winner-mode 1)
#+END_SRC

** Project management

~Project.el~ is shipping with newer versions of Emacs and can replace
my uses of ~projectile~ while being a simpler package. In Emacs 27 and
beyond, project.el has a default binding of ~<C-x p>~.

NOTE: ~project.el~ needs access to a ~find~ executable which is unavailable
on Windows by default, so MSYS2 or Cygwin must be installed. 

** Buffer management
IBuffer is a built-in replacement for list-buffers which is much nicer
and with a lot of additional functionality. Together with ~ivy-rich~,
this provides a good-enough buffer management experience.

#+BEGIN_SRC emacs-lisp
  (global-set-key (kbd "C-x C-b") 'ibuffer)
#+END_SRC

** Windows
   
The ~ace-window~ package is great for jumping between windows.
The [[https://github.com/abo-abo/ace-window#change-the-action-midway][dispatch keys]] are very useful!

#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :bind ("M-o" . ace-window))
#+END_SRC

* Navigation

Avy is fantastic for jumping around the buffer. I'm partial to the
two-key jump, word jump, and line jump, since that combination allows
moving anywhere on screen pretty easily. Avy is important enough that
it gets it's own leader key bindings, so ~avy-goto-char-2~ is bound
there.

#+begin_src emacs-lisp :noweb-ref "leader-avy" :tangle no
'("r" . avy-goto-char-2)
#+end_src

Combined with ~swiper~ for in-buffer search and ~counsel-rg~ for
cross-buffer search, it is easy to navigate anywhere quite easily.

#+BEGIN_SRC emacs-lisp
  (use-package avy
    :bind (("M-g M-g" . avy-goto-line)
	   ("M-g g" . avy-goto-line)
	   ("M-g w" . avy-goto-word-1)))
#+END_SRC

* Prose and life management


By default, text should auto-fill to 80 characters. This makes it
easier to work with olivetti, and makes vertical splits much more
comfortable.

#+BEGIN_SRC emacs-lisp
(add-hook 'text-mode-hook 'auto-fill-mode)
#+END_SRC

** Org mode

Instead of indenting all text to match the header, I like only
indenting the header, so that I have more horizontal characters for
each line.

#+BEGIN_SRC emacs-lisp
(setq org-indent-indentation-per-level 1)
(setq org-adapt-indentation nil)
#+END_SRC

The leading stars in headers can be visually noisy for very nested
documents, so they are disabled. ~org-bullets-mode~ is another option,
but has been causing slowdowns for some larger org documents.

#+BEGIN_SRC emacs-lisp
(setq org-hide-leading-stars 't)
#+END_SRC

When reading documents, it's better if markup is hidden unless
hovered.

#+BEGIN_SRC emacs-lisp
(setq org-hide-emphasis-markers t)
#+END_SRC

Org has a tendency to do weird stuff with whitespace when toggling
headings. Disable this behavior. Also, display the spacing between
headings even when they are closed.

#+BEGIN_SRC emacs-lisp
  (setq org-cycle-separator-lines 1)
  (customize-set-variable 'org-blank-before-new-entry
			  '((heading . nil)
			    (plain-list-item . nil)))
#+END_SRC

Globally useful org commands such as ~org-store-link~ are made available in
the leader key bindings under the "a" prefix.

#+begin_src emacs-lisp :noweb-ref "leader-org" :tangle no
'("a a" . org-agenda)
'("a c" . org-capture)
'("a l" . org-store-link)
#+end_src
 
** Markdown

Sometimes I work with markdown, for instance when writing
documentation for packages at work.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :mode (("README\\.md\\'" . gfm-mode)
	   ("\\.md\\'" . markdown-mode)
	   ("\\.markdown\\'" . markdown-mode))
    :init
    (setq markdown-command "multimarkdown"))
#+end_src

* Programming

** Autocompletion

Since ~lsp-mode~ has started using ~capf~ as the completion backend, I can
use the ~complete-symbol~ with Ivy to fuzzy find completion matches.
This is nice, since for me completion is mainly useful while exploring
new libraries and codebases, and can be distracting otherwise. Using
~ivy~ and ~complete-symbol~ makes completion something that doesn't
distract when it doesn't have to, and makes it possible to explore
symbols using the ~ivy~ fuzzy search when completion is needed.

Completion can be called using the default binding ~<C-M-i>~.

** Snippets

Yasnippet is used for snippet support.

#+begin_src emacs-lisp
  (use-package yasnippet
    :init
    (yas-global-mode))
#+end_src

A bunch of default snippets are found in an external package.

#+begin_src emacs-lisp
  (use-package yasnippet-snippets)
#+end_src

** Errors

Flycheck performs error checking. There is also the built-in ~flymake~,
but I've had crashes on Windows when ~flymake~ tries to check a buffer
that's currently used by another process (such as when formatting a
buffer).

#+begin_src emacs-lisp
  (use-package flycheck)
#+end_src

Integration with ~lsp-mode~ is automatic.

** LSP

The main coding environment is provided by the ~lsp-mode~ package
family, which just keeps getting better and better.

It is available under the ~<C-c l>~ prefix.

#+begin_src emacs-lisp
    (use-package lsp-mode
      :hook ((lsp-mode . lsp-enable-which-key-integration))
      :defer nil
      :custom
      (lsp-keymap-prefix "C-c l")
      (lsp-prefer-capf t))
#+end_src

~lsp-ui~ provides some nice additional features such as a peek mode for
finding references and documentation display. However, I don't like
the sideline display, as it is too noisy.

#+begin_src emacs-lisp
  (use-package lsp-ui
    :commands lsp-ui-mode
    :hook (lsp-mode . lsp-ui-mode)
    :custom
    (lsp-ui-sideline-enable nil)
    (lsp-ui-doc-enable nil)
    :config
    <<lsp-ui-peek-binds>>)
#+end_src

In buffers with ~lsp-ui~ enabled, rebind the ~xref~ commands to use the
peek mode.

#+begin_src emacs-lisp :noweb-ref "lsp-ui-peek-binds" :tangle no
  (define-key lsp-ui-mode-map [remap xref-find-definitions] #'lsp-ui-peek-find-definitions)
  (define-key lsp-ui-mode-map [remap xref-find-references] #'lsp-ui-peek-find-references)
#+end_src

~lsp-mode~ integrates with Ivy for jumping to symbols in the current
workspace.

#+begin_src emacs-lisp
    (use-package lsp-ivy
      :bind (:map lsp-ui-mode-map
		  ("C-c l g s" . lsp-ivy-workspace-symbol))
      :commands lsp-ivy-workspace-symbol)
#+end_src

** Debugging

The ~lsp-mode~ supports debugging through the Debug Adapter Protocol.
It is available when LSP is enabled, but only for filetypes that have
a DAP adapter installed.

#+begin_src emacs-lisp
  (use-package dap-mode
    :commands (dap-mode dap-debug dap-hydra/body))
#+end_src

The ~dap-mode~ binding setup is used for modes that support debugging.
#+begin_src emacs-lisp :noweb-ref "dap-bindings" :tangle no
("C-c C-d" . dap-debug)
#+end_src

** Structured editing

Smartparens enables features of structured editing into any language
that can display pairs, and integrates with ~meow~. 

#+begin_src emacs-lisp
  (use-package smartparens
    :delight
    :commands (sp-local-pair smartparens-global-mode sp-use-paredit-bindings)
    :init
    (sp-local-pair 'emacs-lisp-mode "`" "'")
    (sp-local-pair 'emacs-lisp-mode "'" nil :actions nil)
    (smartparens-global-mode)
    (sp-use-paredit-bindings))
#+end_src

** Languages

*** JavaScript


In Emacs 27, there is a new built-in JavaScript mode which is much
better than earlier modes, and supports JSX syntax well.

#+begin_src emacs-lisp
  (use-package js-mode
    :straight nil
    :hook ((js-mode . lsp-mode)
	   (js-mode . dap-auto-configure-mode)
	   (js-jsx-mode . lsp-mode)
	   (js-jsx-mode . dap-auto-configure-mode))
    :bind ((:map js-mode-map
		 <<dap-bindings>>)
	   (:map js-jsx-mode-map
		 <<dap-bindings>>)))
#+end_src

*** Rust

Rust is well-supported by the ~rust-analyzer~ LSP server. The ~rustic~
mode automatically sets up all the things you'd like to have when
working with Rust and Emacs.

#+begin_src emacs-lisp
      (use-package rustic
	:commands (rustic-mode)
	:custom
	(rustic-lsp-server 'rust-analyzer))
#+end_src

Rustic supports a popup for controlling various compilation, testing
etc. commands. By default it is bound to ~<C-c C-p>~.

* Version control

Magit is the best git client ever.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind ("C-x g" . magit-status))
#+END_SRC

When programming, it is useful to see which lines have been changed
when editing a file. ~Git-Gutter~ does this. I like the ~git-gutter-+~
package which has a nice minimal skin.

#+BEGIN_SRC emacs-lisp
  (use-package git-gutter-fringe+
    :delight
    :hook (prog-mode . git-gutter+-mode)
    :init
    (require 'git-gutter-fringe+)
    (git-gutter-fr+-minimal)
    (git-gutter+-toggle-fringe))
#+END_SRC

Every once in a while it's nice to visit older versions of a
file. Magit can do this, but is somewhat cumbersome to
use. ~git-timemachine~ provides an easy-to-use alternative.

#+BEGIN_SRC emacs-lisp
  (use-package git-timemachine
    :delight
    :commands (git-timemachine)
    :bind ("C-x M-g" . git-timemachine))
#+END_SRC

* Supporting code

Ivy-rich must be enabled after other ivy integrations, so enabling it
is deferred to the end of initialization.

#+BEGIN_SRC emacs-lisp
<<ivy-rich>>
#+END_SRC
