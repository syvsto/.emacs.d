#+TITLE: My Emacs configuration
#+PROPERTY: tangle "init.el"
#+PROPERTY: header-args :results silent :noweb yes

This configuration focuses on modal bindings and general ergonomics to reduce
risk of RSI while sticking to "the emacs way", meaning it tries to avoid too
much rebinding across packages such as done by spacemacs and doom.

* Initialization

The config uses ~straight.el~ as the package manager, since it allows the use of
various packages that only are available on github. Additionally, ~use-package~ is
used to configure the packages, as it allows for clean separation of setting
options, and eases deferring the loading of packages.

** Bootstrap straight

The ~straight.el~ bootstrap code is performed in the ~init.el~ file because ~straight~
needs to make sure it controls which version of ~org~ is loaded, and I tangle this
file on startup.

In order to avoid loading the built-in ~org-mode~, the ~init.el~ file makes sure the
upstream version is loaded before other packages start using ~org-mode~
functionality.

** Use-package

With straight installed, ~use-package~ can be installed using the
~(straight-use-package)~ function.

#+BEGIN_SRC emacs-lisp
  (straight-use-package 'use-package)
#+END_SRC

Use-package uses the built-in ~package.el~ by default, and eagerly loads packages.
To reduce startup times and use ~straight~ for package installation, some options
for ~use-package~ need to be set.

#+BEGIN_SRC emacs-lisp
  (setq straight-use-package-by-default t)
  (setq use-package-always-defer t)
#+END_SRC

** Cleaning up Emacs' trash

By default, emacs will put a lot of files on various places on the hard drive.
The ~no-littering~ package organizes these files in a better manner, keeping
things more organized.

#+BEGIN_SRC emacs-lisp
  (use-package no-littering
    :demand t)
#+END_SRC

** Essential libraries for elisp

There are some libraries that are very commonly used when working with elisp, to
alleviate some of the pain points of the language.

~s.el~ contains various convenience functions for working with strings.

#+BEGIN_SRC emacs-lisp
  (use-package s)
#+END_SRC

~dash~ contains various convenience functions for working with lists.

#+BEGIN_SRC emacs-lisp
  (use-package dash)
#+END_SRC

** Environment variables

On MacOS, you often don't get the correct $PATH when using GUI Emacs. The
~exec-path-from-shell~ package fixes this.

#+begin_src emacs-lisp
  (use-package exec-path-from-shell
    :commands (exec-path-from-shell-initialize)
    :init
    (when (memq window-system '(mac ns x))
      (exec-path-from-shell-initialize)))
#+end_src

** Important initial settings
   
Some settings *must* be changed to make Emacs usable. Importantly, it should not
be necessary to type "yes" and "no" for every prompt!  However, to avoid killing
Emacs by accident, prompt when the ~kill-emacs~ function is called.

#+BEGIN_SRC emacs-lisp
  (defalias 'yes-or-no-p 'y-or-n-p)
  (setq confirm-kill-emacs 'y-or-n-p)
#+END_SRC

Since it is easy to mistype things, the error bell sound of Emacs can become
annoying.  Disable it.

#+BEGIN_SRC emacs-lisp
  (setq ring-bell-function 'ignore)
#+END_SRC

Also, there is not much point in having the menu bar and scroll bars visible, as
the information is available elsewhere.

#+BEGIN_SRC emacs-lisp
  (tool-bar-mode -1)
  (menu-bar-mode -1)
  (toggle-scroll-bar -1)
#+END_SRC

Emacs should use UTF-8 encoding by default, as has become common.
#+begin_src emacs-lisp
  (prefer-coding-system 'utf-8)
  (set-default-coding-systems 'utf-8)
  (set-language-environment 'utf-8)
  (set-selection-coding-system 'utf-8)
#+end_src

Finally, get rid of the default splash screen and jump straight to a scratch
buffer.

#+begin_src emacs-lisp
  (setq inhibit-startup-screen t)
  (setq inhibit-startup-message t)
  (setq initial-scratch-message ";; INITIALIZED...")
#+end_src

** Mac specifics 

On Mac, I like keeping the right alt modifier as-is, to be able to input special
characters with ease.

#+begin_src emacs-lisp
  (setq ns-right-alternate-modifier nil)
#+end_src

A small aesthetic change is keeping the title bar and theme in the same color.

#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
#+end_src

* Key bindings and navigation

Vim bindings for that sweet RSI relief.

#+begin_src emacs-lisp
  (use-package evil
    :init
    (setq evil-want-keybinding nil)
    :hook (after-init . evil-mode))

  (use-package evil-collection
    :hook (evil-mode . evil-collection-init))

  (use-package evil-magit
    :hook (evil-mode . evil-magit-init))

  (use-package evil-matchit
    :hook (after-init . global-evil-matchit-mode))
#+end_src

Some additional plugins are essential.
#+begin_src emacs-lisp
  (use-package evil-surround
    :hook (evil-mode . global-evil-surround-mode))

  (use-package evil-commentary
    :hook (evil-mode . evil-commentary-mode))
#+end_src

** Completion

I'm trying out using the built-in minibuffer and completion styles, which
together with ~orderless~ gives a pretty nice completion experience.

#+BEGIN_SRC emacs-lisp
  (defun up-directory (arg)
    "Move up a directory"
    (interactive "p")
    (if (string-match-p "/." (minibuffer-contents))
	(zap-up-to-char (- arg) ?/)
      (delete-minibuffer-contents)))

  (use-package minibuffer
    :straight nil
    :bind ((:map minibuffer-local-completion-map
		 ("<tab>" . minibuffer-complete)
		 ("<M-enter>" . minibuffer-force-complete)
		 ("SPC"))
	   (:map minibuffer-local-filename-completion-map
		 ("<C-backspace>" . up-directory)))
    :custom
    (completion-category-defaults nil)
    (completion-cycle-threshold 5)
    (completion-ignore-case t)
    (resize-mini-windows t)
    (completions-format 'vertical)
    (enable-recursive-minibuffers t)
    (minibuffer-depth-indicate-mode t)
    (minibuffer-eldef-shorten-default t)
    (minibuffer-electric-default-mode t))

  (use-package completion-list
    :straight nil
    :bind (:map completion-list-mode-map
		("j" . next-completion)
		("k" . previous-completion)
		("/" . evil-search-forward)
		("?" . evil-search-backward)
		("n" . evil-search-next)
		("N" . evil-search-previous)))

  (use-package orderless
    :custom
    (completion-styles '(orderless))
    (orderless-component-separator "[ ]+"))
#+END_SRC

The completion mechanism can be used for in-buffer completions as well. By
default, the buffer pops up covering the entire screen, which is not what I want.

#+begin_src emacs-lisp
    (setq tab-always-indent 'complete)

    (defun completing-read-in-region (start end collection &optional predicate)
      "Prompt for completion of region in the minibuffer if non-unique.
			    Use as a value for `completion-in-region-function'."
      (if (and (minibufferp) (not (string= (minibuffer-prompt) "Eval: ")))
	  (completion--in-region start end collection predicate)
	(let* ((initial (buffer-substring-no-properties start end))
	       (limit (car (completion-boundaries initial collection predicate "")))
	       (all (completion-all-completions initial collection predicate
						(length initial)))
	       (completion (cond
			    ((atom all) nil)
			    ((and (consp all) (atom (cdr all)))
			     (concat (substring initial 0 limit) (car all)))
			    (t (completing-read
				"Completion: " collection predicate t initial)))))
	  (if (null completion)
	      (progn (message "No completion") nil)
	    (delete-region start end)
	    (insert completion)
	    t))))

  (setq completion-in-region-function #'completing-read-in-region)
#+end_src

Embark makes it possible to act upon completion candidates, and has a nice
occur live display for showing completions.

#+begin_src emacs-lisp
  (use-package embark
    :straight (:type git :host github :repo "oantolin/embark")
    :commands (embark-completing-read)
    :bind
    (:map minibuffer-local-map
	  (">" . embark-become))
    (:map minibuffer-local-completion-map
	  (";" . embark-act-noexit)
	  ("C-o" . embark-occur)
	  ("C-l" . embark-live-occur)
	  ("M-v" . embark-switch-to-live-occur)
	  (":" . embark-act))
    (:map completion-list-mode-map
	  (";" . embark-act))
    (:map embark-occur-mode-map
	  ("j" . next-line)
	  ("k" . previous-line)
	  ("n" . evil-search-next)
	  ("N" . evil-search-previous)
	  ("/" . evil-search-forward)
	  ("?" . evil-search-backward))
    :custom
    (embark-occur-minibuffer-completion t)
    (completing-read-function 'embark-completing-read)
    :config
    (add-to-list 'evil-emacs-state-modes 'embark-occur-mode))
#+end_src

Embark creates a lot of buffers by default, which I would like to hide. By
creating my own ~read-buffer~ I can control how the buffers are filtered.
#+begin_src emacs-lisp
  (defun my/match-buffers (buf)
    (let ((b (if (stringp buf)
		 buf
	       (car buf)))))
    (not (string-match "\\*Embark Live Occur\\*" (car buf))))

  (defun my/read-buffer (prompt &optional def require-match predicate)
    (let ((read-buffer-function nil))
      (read-buffer prompt def require-match #'my/match-buffers)))

  (setq read-buffer-function 'my/read-buffer)
#+end_src

** Search

When searching across buffers, I like ~ripgrep~, which can be invoked
with the =deadgrep= package.

#+begin_src emacs-lisp
  (use-package deadgrep
    :bind ("C-c r" . deadgrep))
#+end_src

** Imenu

IMenu is a useful, built-in navigation tool for many modes, but is unbound. Bind to ~M-i~,
since that's only used for indentation by default.
#+begin_src emacs-lisp
  (bind-key "M-i" 'imenu)
#+end_src

However, IMenu will often require navigating through multiple menus. Since I
have fuzzy completion it's better if the list of IMenu entries can be searched
in its entirety. The ~flimenu~ package flattens the ~imenu~ so this works.

#+begin_src emacs-lisp
  (use-package flimenu
    :hook (after-init . flimenu-global-mode))
#+end_src

** IBuffer

Similar to IMenu, IBuffer is a nice built-in replacement for ~list-buffers~

#+begin_src emacs-lisp
(bind-key "C-x C-b" 'ibuffer)
#+end_src

** Crux

  The Crux package contains a bunch of useful shortcuts.

#+begin_src emacs-lisp
  (use-package crux
    :bind (("C-c o" . crux-open-with)
	   ("C-c n" . crux-cleanup-buffer-or-region)
	   ("C-c u" . crux-view-url)
	   ("C-c e" . crux-eval-and-replace)
	   ("C-x 4 t" . crux-transpose-windows)
	   ("C-c k" . crux-kill-other-buffers)
	   ("C-c D" . crux-delete-file-and-buffer)))
#+end_src

** Kill ring navigation

It can be a hassle to navigate the kill ring manually (~C-y M-y M-y M-y~
etc.). =browse-kill-ring= brings up the kill ring as a navigable buffer for easier
candidate selection.

#+begin_src emacs-lisp
  (use-package browse-kill-ring
    :bind ("M-y" . browse-kill-ring))
#+end_src

* Looks and layout

** Theme and fonts  
Most themes are optimized for code. Since this Emacs config should be useable
for both code and prose, a theme that supports both is chosen. ~Modus Operandi~
and ~Modus Vivendi~ are nice light and dark themes with a focus on accessibility
and support for any mode under the sun. For the most part, I like the light
variant, however, in a terminal the dark theme is better.

#+BEGIN_SRC emacs-lisp
  (use-package modus-operandi-theme)

  (use-package modus-vivendi-theme
    :init
    (load-theme 'modus-vivendi t))
#+END_SRC

Jetbrains Mono is a great coding font; clear to read and with enough of a
personal look to make it fun.

#+BEGIN_SRC emacs-lisp
  (set-face-attribute 'default nil :family "Jetbrains Mono" :height 140)
  (set-face-attribute 'fixed-pitch nil :family "Jetbrains Mono" :height 140)
  (set-face-attribute 'variable-pitch nil :family "Jetbrains Mono" :height 140)
#+END_SRC

** Modeline

The modeline can also use a little facelift.
#+begin_src emacs-lisp
  (use-package mood-line
  :hook (after-init . mood-line-mode))
#+end_src

I like seeing the current time when I'm working, as I often run Emacs in
full-screen mode. I don't need to see my computer's load level, so that is
hidden.

#+begin_src emacs-lisp
  (setq display-time-default-load-average nil)
  (setq display-time-format " %k:%M")
  (display-time-mode 1)
#+end_src

** Icons

Iconography allows quickly identifying information about an object. For
instance, files are easier to identify when their file type is shown as an
icon. The ~all-the-icons~ family of packages enables icons for various emacs
modes.

The base package.
#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons)
#+END_SRC

Integration with Dired, which displays file types as an icon.

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons-dired
    :hook (dired-mode . all-the-icons-dired-mode))
#+END_SRC

IBuffer can also display file types of buffers using all-the-icons.

#+BEGIN_SRC emacs-lisp
  (use-package all-the-icons-ibuffer
    :init
    (all-the-icons-ibuffer-mode 1))
#+END_SRC

*** Font caches

Emacs may render icons slowly due to the way fonts are cached.  Performance can
be increased by not compacting font caches, at the cost of some RAM.

#+BEGIN_SRC emacs-lisp
  (setq inhibit-compacting-font-caches t)
#+END_SRC

** Showing key bindings

~which-key~ displays the key bindings available for a hotkey after a
short while. This helps discoverability immensely.

#+BEGIN_SRC emacs-lisp
  (use-package which-key
    :init
    (which-key-mode))
#+END_SRC
   
** Layout

When writing prose, I want the layout be as distraction-free as
possible. Olivetti-mode supports this with minimal fuzz. Olivetti defaults to a
width of 70, which is a tad too narrow for my taste, so it is raised to 80.

#+BEGIN_SRC emacs-lisp
  (use-package olivetti
    :hook (text-mode . olivetti-mode)
    :custom
    (olivetti-body-width 82))
#+END_SRC

Emacs is commonly used maximized. Default to maximizing Emacs on startup.

#+begin_src emacs-lisp
  (add-to-list 'default-frame-alist '(fullscreen . maximized))
#+end_src

** Rainbow delimiters

Rainbow delimiters make it easier to spot nesting of parentheses etc.
#+begin_src emacs-lisp
  (use-package rainbow-delimiters
    :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

* Windows, projects, and buffers
  
Emacs comes with ~winner-mode~, which allows navigating to old window layouts.
Great if you accidentally close your windows!

#+BEGIN_SRC emacs-lisp
  (winner-mode 1)
#+END_SRC

** Project management

Done by the built-in ~project.el~.

** Buffer management
IBuffer is a built-in replacement for list-buffers which is much nicer and with
a lot of additional functionality. It can be used in conjunction with the
=perspective.el= wrapper ~persp-ibuffer~ to show only buffers in the current
perspective. It is bound in the [[*Perspectives][perspective section]] of this document.

** Windows
   
The ~ace-window~ package is great for jumping between windows.  The [[https://github.com/abo-abo/ace-window#change-the-action-midway][dispatch keys]]
are very useful!

#+BEGIN_SRC emacs-lisp
  (use-package ace-window
    :bind ("M-o" . ace-window))
#+END_SRC

** File system

Dired is great for generic movement around the file system, as well as generic
options such as copying and renaming files across folders. However, it defaults
to displaying too much information, and feels cluttered. Disable this extra
information. If needed, it is available under the ~(~ key.

#+begin_src emacs-lisp
  (use-package dired
    :straight nil
    :ensure nil
    :hook (dired-mode . dired-hide-details-mode))
#+end_src

* Prose and life management

By default, text should auto-fill to 80 characters. This makes it easier to work
with olivetti, and makes vertical splits much more comfortable.

#+BEGIN_SRC emacs-lisp
  (setq-default fill-column 80)
  (add-hook 'text-mode-hook 'auto-fill-mode)
#+END_SRC

** Org mode

Instead of indenting all text to match the header, I like only indenting the
header, so that I have more horizontal characters for each line.

#+BEGIN_SRC emacs-lisp
  (setq org-indent-indentation-per-level 1)
  (setq org-adapt-indentation nil)
#+END_SRC

The leading stars in headers can be visually noisy for very nested documents, so
they are disabled. ~org-bullets-mode~ is another option, but has been causing
slowdowns for some larger org documents.

#+BEGIN_SRC emacs-lisp
  (setq org-hide-leading-stars 't)
#+END_SRC

When reading documents, it's better if markup is hidden unless hovered.

#+BEGIN_SRC emacs-lisp
  (setq org-hide-emphasis-markers t)
#+END_SRC

Org has a tendency to do weird stuff with whitespace when toggling
headings. Disable this behavior. Also, display the spacing between headings even
when they are closed.

#+BEGIN_SRC emacs-lisp
  (setq org-cycle-separator-lines 1)
  (customize-set-variable 'org-blank-before-new-entry
			  '((heading . nil)
			    (plain-list-item . nil)))
#+END_SRC

*** The agenda

The org files needed for my agenda is available in my Dropbox folder.

#+begin_src emacs-lisp
  (setq my/org-agenda-dir "~/Dropbox/orgfiles/")
#+end_src

#+begin_src emacs-lisp
    (setq org-directory my/org-agenda-dir
	  org-agenda-files (concat user-emacs-directory "agenda-files"))
#+end_src

Org capture requires capture templates to be the most useful.

#+begin_src emacs-lisp
  (setq org-capture-templates
	`(("i" "inbox" entry (file ,(concat my/org-agenda-dir "inbox.org"))
	   "* TODO %?")))
#+end_src

Org agenda is nice for seeing an overview of the state of various org files at
once. Set it up so it shows my todos from various files.

#+begin_src emacs-lisp
    (setq my/org-agenda-todo-view
	  `(" " "Agenda"
	    ((agenda ""
		     ((org-agenda-span 'day)
		      (org-deadline-warning-days 365)))
	     (todo "TODO"
		   ((org-agenda-overriding-header "Inbox")
		    (org-agenda-files '(,(concat my/org-agenda-dir "inbox.org")))))
	     (todo "TODO"
		   ((org-agenda-overriding-header "Eposter")
		    (org-agenda-files '(,(concat my/org-agenda-dir "emails.org")))))
	     (todo "NEXT"
		   ((org-agenda-overriding-header "In Progress")
		    (org-agenda-files '(,(concat my/org-agenda-dir "someday.org")
					,(concat my/org-agenda-dir "projects.org")
					,(concat my/org-agenda-dir "next.org")))
		    ))
	     (todo "TODO"
		   ((org-agenda-overriding-header "Prosjekter")
		    (org-agenda-files '(,(concat my/org-agenda-dir "projects.org")))
		    ))
	     (todo "TODO"
		   ((org-agenda-overriding-header "Enkeltoppgaver")
		    (org-agenda-files '(,(concat my/org-agenda-dir "next.org")))
		    (org-agenda-skip-function '(org-agenda-skip-entry-if 'deadline 'scheduled))))
	     nil)))

    (use-package org
      :bind (("C-c c" . org-capture)
	     ("C-c l" . org-store-link))
      :init
      (setq org-agenda-custom-commands (list my/org-agenda-todo-view)))
#+end_src

Show todo items in agenda that have been set to done in this session, or are
scheduled for today.

#+begin_src emacs-lisp
  (setq org-agenda-start-with-log-mode t)
#+end_src

There are some unnecessary horizontal lines in the agenda that take up space and
clutter the view. Remove them.
#+begin_src emacs-lisp
  (setq org-agenda-block-separator nil)
#+end_src

Make the agenda real easy to get to, to reduce overhead when working with task
management. This binds a shortcut to my agenda view to ~<F1>~.

#+begin_src emacs-lisp
  (defun my/org-agenda ()
    "Show my org agenda"
    (interactive)
    (org-agenda nil " "))

  (bind-key "<f1>" 'my/org-agenda)
#+end_src


***** Refiling

Org mode is better if you can move stuff around easily. This is called refiling.
#+begin_src emacs-lisp
  (setq org-refile-use-outline-path 'file
	org-outline-path-complete-in-steps nil)
#+end_src

I need some targets to refile to.

#+begin_src emacs-lisp
  (setq org-refile-targets '(("next.org" :level . 0)
			     ("someday.org" :level . 0)
			     ("calendar.org" :level . 0)
			     ("emails.org" :level . 0)
			     ("projects.org" :maxlevel . 1)))
#+end_src
 
** Markdown

Sometimes I work with markdown, for instance when writing documentation for
packages at work.

#+begin_src emacs-lisp
  (use-package markdown-mode
    :mode (("README\\.md\\'" . gfm-mode)
	   ("\\.md\\'" . markdown-mode)
	   ("\\.markdown\\'" . markdown-mode))
    :init
    (setq markdown-command "multimarkdown"))
#+end_src

* Programming

Line numbers are useful for navigation when using prog-mode.

#+begin_src emacs-lisp
  (add-hook 'prog-mode-hook 'display-line-numbers-mode)
#+end_src

** Snippets

Yasnippet is used for snippet support.

#+begin_src emacs-lisp
  (use-package yasnippet
    :init
    (yas-global-mode))
#+end_src

A bunch of default snippets are found in an external package.

#+begin_src emacs-lisp
      (use-package yasnippet-snippets
	:config
	(yasnippet-snippets-initialize))
#+end_src

** Errors

Flycheck performs error checking. There is also the built-in ~flymake~, but I've
had crashes on Windows when ~flymake~ tries to check a buffer that's currently
used by another process (such as when formatting a buffer).

#+begin_src emacs-lisp
  (use-package flycheck)
#+end_src

Integration with ~lsp-mode~ is automatic.

** LSP

The main coding environment is provided by the ~lsp-mode~ package family, which
just keeps getting better and better.

It is available under the ~<f6>~ prefix.

#+begin_src emacs-lisp
  (use-package lsp-mode
    :hook ((lsp-mode . lsp-enable-which-key-integration))
    :custom
    (lsp-keymap-prefix "<f6>")
    (lsp-prefer-capf t))
#+end_src

~lsp-ui~ provides some nice additional features such as a peek mode for finding
references and documentation display. However, I don't like the sideline
display, as it is too noisy.

#+begin_src emacs-lisp
  (use-package lsp-ui
    :commands lsp-ui-mode
    :hook (lsp-mode . lsp-ui-mode)
    :custom
    (lsp-ui-sideline-enable nil)
    (lsp-ui-doc-enable nil)
    (lsp-ui-doc-position 'at-point))
#+end_src

** Structured editing

Smartparens enables features of structured editing into any language that can
display pairs. 

#+begin_src emacs-lisp
  (use-package smartparens
    :commands (sp-local-pair smartparens-global-mode sp-use-paredit-bindings)
    :init
    (sp-local-pair 'emacs-lisp-mode "`" "'")
    (sp-local-pair 'emacs-lisp-mode "'" nil :actions nil)
    (smartparens-global-mode)
    (sp-use-paredit-bindings))
#+end_src

** Languages

*** JavaScript

In Emacs 27, there is a new built-in JavaScript mode which is much better than
earlier modes, and supports JSX syntax well.

#+begin_src emacs-lisp
  (use-package js-mode
    :straight nil
    :hook ((js-mode . lsp-deferred)
	   (js-mode . dap-auto-configure-mode)
	   (js-mode . (lambda () (setq tab-width 2)))
	   (js-jsx-mode . lsp-deferred)
	   (js-jsx-mode . dap-auto-configure-mode))
    :bind ((:map js-mode-map
		 ("M-." . xref-find-references)
		 <<dap-bindings>>)
	   (:map js-jsx-mode-map
		 <<dap-bindings>>))
    )
#+end_src

I often use =prettier= as my formatter. The =prettier.el= package is good for
handling autoformat on save etc. ~global-prettier-mode~ enables Prettier for
javascript, typescript etc.

#+begin_src emacs-lisp
  (use-package prettier-js
    :hook ((js-mode scss-mode css-mode json-mode) . prettier-js-mode))
#+end_src

*** JSON

JSON-mode includes some niceties for working with JSON, including a formatter in ~json-format~.
#+begin_src emacs-lisp
(use-package json-mode)
#+end_src

*** Rust

Rust is well-supported by the ~rust-analyzer~ LSP server. The ~rustic~ mode
automatically sets up all the things you'd like to have when working with Rust
and Emacs.

#+begin_src emacs-lisp
  (use-package rustic
    :commands (rustic-mode)
    :custom
    (rustic-lsp-server 'rust-analyzer))
#+end_src

Rustic supports a popup for controlling various compilation, testing
etc. commands. By default it is bound to ~<C-c C-p>~.

*** Haskell

Haskell does not yet have great LSP support in Emacs, though it is in the works in the
form of =haskell-language-server=. Instead, the emacs =haskell-mode= contains a lot
of useful features for working with Haskell.

#+begin_src emacs-lisp
  (use-package haskell-mode
    :bind (:map haskell-mode-map
		("<f8>" . haskell-navigate-imports))
    :hook ((haskell-mode . haskell-auto-insert-module-template)))
#+end_src

This sets up Dante, with the assumption that nix is installed and used.

#+begin_src emacs-lisp
  (use-package dante
    :after haskell-mode
    :commands 'dante-mode
    :hook ((haskell-mode . flycheck-mode)
	   (haskell-mode . dante-mode))
    :config
    (setq dante-methods '(new-build bare-ghci)))
#+end_src

=Attrap= adds various code actions to =dante= (on windows you need to set the beta
option for UTF-8 in Region settings for it to work).
#+begin_src emacs-lisp
  (use-package attrap)
#+end_src

*** Nix

Nix syntax  is used to write code for the Nix package management/build/system
management/OS tool.

#+begin_src emacs-lisp
  (use-package nix-mode)
#+end_src

* Version control

Magit is the best git client ever.

#+BEGIN_SRC emacs-lisp
  (use-package magit
    :bind ("C-x g" . magit-status))
#+END_SRC

When programming, it is useful to see which lines have been changed when editing
a file. ~Git-Gutter~ does this. I like the ~git-gutter-+~ package which has a nice
minimal skin.

#+BEGIN_SRC emacs-lisp
  (use-package git-gutter-fringe+
    :hook (prog-mode . git-gutter+-mode)
    :init
    (require 'git-gutter-fringe+)
    (git-gutter-fr+-minimal)
    (git-gutter+-toggle-fringe))
#+END_SRC

Every once in a while it's nice to visit older versions of a file. Magit can do
this, but is somewhat cumbersome to use. ~git-timemachine~ provides an easy-to-use
alternative.

#+BEGIN_SRC emacs-lisp
  (use-package git-timemachine
    :commands (git-timemachine)
    :bind ("C-x G" . git-timemachine))
#+END_SRC
